// Generated by Gemini
#include "gtest/gtest.h"
#include "lexer.h"

namespace rs = insomnia::rust_shard;

// Change TKT enum content to start with 'k' and use PascalCase
using TKT = rs::TokenType;

std::vector<std::pair<TKT, std::string>> get_token_pairs(const std::string &source_code) {
  rs::Lexer lexer(source_code);
  EXPECT_TRUE(lexer.is_good()) << lexer.error_msg();
  std::vector<std::pair<TKT, std::string>> res;
  for(auto &token: lexer.tokens()) {
    res.emplace_back(token.type, std::string(token.lexeme));
  }
  return res;
}

// expected_tokens should be parenthesized like a initializer list.
// Refer to the samples.
#define TEST_LEXER_SUCCESS(test_name, source_code, expected_tokens) \
  TEST(LexerTest, test_name) { \
    auto tokens = get_token_pairs(source_code); \
    auto expected = std::vector<std::pair<TKT, std::string>> expected_tokens; \
    ASSERT_EQ(tokens, expected); \
  }

#define TEST_LEXER_FAILURE(test_name, source_code) \
  TEST(LexerTest, test_name) { \
    rs::Lexer lexer(source_code); \
    ASSERT_FALSE(lexer.is_good()); \
  }

// --- Keywords and Identifiers ---
TEST_LEXER_SUCCESS(KeywordsAndIdentifiers,
  "let mut my_var: i32 = true;",
  ({
    {TKT::kLet, "let"}, {TKT::kMut, "mut"}, {TKT::kIdentifier, "my_var"},
    {TKT::kColon, ":"}, {TKT::kIdentifier, "i32"}, {TKT::kEq, "="},
    {TKT::kTrue, "true"}, {TKT::kSemi, ";"}
  }));

TEST_LEXER_SUCCESS(AllKeywords,
  "as break const continue crate else enum extern false fn for if impl in "
  "let loop match mod move mut pub ref return self Self super trait true type "
  "unsafe use where while async await dyn",
  ({
    {TKT::kAs, "as"}, {TKT::kBreak, "break"}, {TKT::kConst, "const"},
    {TKT::kContinue, "continue"}, {TKT::kCrate, "crate"}, {TKT::kElse, "else"},
    {TKT::kEnum, "enum"}, {TKT::kExtern, "extern"}, {TKT::kFalse, "false"},
    {TKT::kFn, "fn"}, {TKT::kFor, "for"}, {TKT::kIf, "if"},
    {TKT::kImpl, "impl"}, {TKT::kIn, "in"}, {TKT::kLet, "let"},
    {TKT::kLoop, "loop"}, {TKT::kMatch, "match"}, {TKT::kMod, "mod"},
    {TKT::kMove, "move"}, {TKT::kMut, "mut"}, {TKT::kPub, "pub"},
    {TKT::kRef, "ref"}, {TKT::kReturn, "return"}, {TKT::kSelfObject, "self"},
    {TKT::kSelfType, "Self"}, {TKT::kSuper, "super"}, {TKT::kTrait, "trait"},
    {TKT::kTrue, "true"}, {TKT::kType, "type"}, {TKT::kUnsafe, "unsafe"},
    {TKT::kUse, "use"}, {TKT::kWhere, "where"}, {TKT::kWhile, "while"},
    {TKT::kAsync, "async"}, {TKT::kAwait, "await"}, {TKT::kDyn, "dyn"}
  }));

TEST_LEXER_SUCCESS(AllPunctuations,
  "+ - * / % ^ ! & | && || << >> += -= *= /= %= ^= &= |= <<= >>= = == != > < >= <= "
  "@ _ . ... .. ..= , ; : :: -> => <- # $ ? ~ ( ) [ ] { }",
  ({
    {TKT::kPlus, "+"}, {TKT::kMinus, "-"}, {TKT::kStar, "*"}, {TKT::kSlash, "/"},
    {TKT::kPercent, "%"}, {TKT::kCaret, "^"}, {TKT::kNot, "!"}, {TKT::kAnd, "&"},
    {TKT::kOr, "|"}, {TKT::kAndAnd, "&&"}, {TKT::kOrOr, "||"}, {TKT::kShl, "<<"},
    {TKT::kShr, ">>"}, {TKT::kPlusEq, "+="}, {TKT::kMinusEq, "-="}, {TKT::kStarEq, "*="},
    {TKT::kSlashEq, "/="}, {TKT::kPercentEq, "%="}, {TKT::kCaretEq, "^="},
    {TKT::kAndEq, "&="}, {TKT::kOrEq, "|="}, {TKT::kShlEq, "<<="}, {TKT::kShrEq, ">>="},
    {TKT::kEq, "="}, {TKT::kEqEq, "=="}, {TKT::kNe, "!="}, {TKT::kGt, ">"}, {TKT::kLt, "<"},
    {TKT::kGe, ">="}, {TKT::kLe, "<="}, {TKT::kAt, "@"}, {TKT::kUnderscore, "_"},
    {TKT::kDot, "."}, {TKT::kDotDotDot, "..."}, {TKT::kDotDot, ".."},
    {TKT::kDotDotEq, "..="}, {TKT::kComma, ","}, {TKT::kSemi, ";"}, {TKT::kColon, ":"},
    {TKT::kPathSep, "::"}, {TKT::kRArrow, "->"}, {TKT::kFatArrow, "=>"},
    {TKT::kLArrow, "<-"}, {TKT::kPound, "#"}, {TKT::kDollar, "$"}, {TKT::kQuestion, "?"},
    {TKT::kTilde, "~"}, {TKT::kLParenthesis, "("}, {TKT::kRParenthesis, ")"},
    {TKT::kLSquareBracket, "["}, {TKT::kRSquareBracket, "]"}, {TKT::kLCurlyBrace, "{"}, {TKT::kRCurlyBrace, "}"}
  }));

// --- Numeric Literals ---
TEST_LEXER_SUCCESS(DecimalNumbers,
  "let n = 123_456; let f = 1.2345;",
  ({
    {TKT::kLet, "let"}, {TKT::kIdentifier, "n"}, {TKT::kEq, "="},
    {TKT::kIntegerLiteral, "123_456"}, {TKT::kSemi, ";"},
    {TKT::kLet, "let"}, {TKT::kIdentifier, "f"}, {TKT::kEq, "="},
    {TKT::kFloatLiteral, "1.2345"}, {TKT::kSemi, ";"}
  }));

TEST_LEXER_SUCCESS(IntegerSuffix,
  "let a = 123u32; let b = 456_isize;",
  ({
    {TKT::kLet, "let"}, {TKT::kIdentifier, "a"}, {TKT::kEq, "="},
    {TKT::kIntegerLiteral, "123u32"}, {TKT::kSemi, ";"},
    {TKT::kLet, "let"}, {TKT::kIdentifier, "b"}, {TKT::kEq, "="},
    {TKT::kIntegerLiteral, "456_isize"}, {TKT::kSemi, ";"}
  }));

// --- String Literals ---
TEST_LEXER_SUCCESS(StringWithEscapes,
  "let s = \"hello\\nworld\";",
  ({
    {TKT::kLet, "let"}, {TKT::kIdentifier, "s"}, {TKT::kEq, "="},
    {TKT::kStringLiteral, "\"hello\\nworld\""}, {TKT::kSemi, ";"}
  }));

// --- Operators and Delimiters ---
TEST_LEXER_SUCCESS(ArithmeticOperators,
  "a + b - c * d / e % f",
  ({
    {TKT::kIdentifier, "a"}, {TKT::kPlus, "+"}, {TKT::kIdentifier, "b"},
    {TKT::kMinus, "-"}, {TKT::kIdentifier, "c"}, {TKT::kStar, "*"},
    {TKT::kIdentifier, "d"}, {TKT::kSlash, "/"}, {TKT::kIdentifier, "e"},
    {TKT::kPercent, "%"}, {TKT::kIdentifier, "f"}
  }));

TEST_LEXER_SUCCESS(ComparisonOperators,
  "a == b != c < d > e <= f >= g",
  ({
    {TKT::kIdentifier, "a"}, {TKT::kEqEq, "=="}, {TKT::kIdentifier, "b"},
    {TKT::kNe, "!="}, {TKT::kIdentifier, "c"}, {TKT::kLt, "<"},
    {TKT::kIdentifier, "d"}, {TKT::kGt, ">"}, {TKT::kIdentifier, "e"},
    {TKT::kLe, "<="}, {TKT::kIdentifier, "f"}, {TKT::kGe, ">="},
    {TKT::kIdentifier, "g"}
  }));

TEST_LEXER_SUCCESS(CompoundOperators,
  "a += b; c *= d; e /= f; g %= h; i ^= j;",
  ({
    {TKT::kIdentifier, "a"}, {TKT::kPlusEq, "+="}, {TKT::kIdentifier, "b"}, {TKT::kSemi, ";"},
    {TKT::kIdentifier, "c"}, {TKT::kStarEq, "*="}, {TKT::kIdentifier, "d"}, {TKT::kSemi, ";"},
    {TKT::kIdentifier, "e"}, {TKT::kSlashEq, "/="}, {TKT::kIdentifier, "f"}, {TKT::kSemi, ";"},
    {TKT::kIdentifier, "g"}, {TKT::kPercentEq, "%="}, {TKT::kIdentifier, "h"}, {TKT::kSemi, ";"},
    {TKT::kIdentifier, "i"}, {TKT::kCaretEq, "^="}, {TKT::kIdentifier, "j"}, {TKT::kSemi, ";"}
  }));

TEST_LEXER_SUCCESS(MiscOperatorsAndDelimiters,
  "let a: Vec<i32> = vec![1, 2, 3];",
  ({
    {TKT::kLet, "let"}, {TKT::kIdentifier, "a"}, {TKT::kColon, ":"},
    {TKT::kIdentifier, "Vec"}, {TKT::kLt, "<"}, {TKT::kIdentifier, "i32"},
    {TKT::kGt, ">"}, {TKT::kEq, "="}, {TKT::kIdentifier, "vec"},
    {TKT::kNot, "!"}, {TKT::kLSquareBracket, "["}, {TKT::kIntegerLiteral, "1"},
    {TKT::kComma, ","}, {TKT::kIntegerLiteral, "2"}, {TKT::kComma, ","},
    {TKT::kIntegerLiteral, "3"}, {TKT::kRSquareBracket, "]"}, {TKT::kSemi, ";"}
  }));

// --- Comments and Whitespace ---
TEST_LEXER_SUCCESS(SingleLineComment,
  "let x = 1; // This is a comment\nlet y = 2;",
  ({
    {TKT::kLet, "let"}, {TKT::kIdentifier, "x"}, {TKT::kEq, "="},
    {TKT::kIntegerLiteral, "1"}, {TKT::kSemi, ";"},
    {TKT::kLet, "let"}, {TKT::kIdentifier, "y"}, {TKT::kEq, "="},
    {TKT::kIntegerLiteral, "2"}, {TKT::kSemi, ";"}
  }));

TEST_LEXER_SUCCESS(MultiLineComment,
  "let a = 1; /* This is a nested /*\nmulti-/*li*/ne\nco*/mment. */ let b = 2;",
  ({
    {TKT::kLet, "let"}, {TKT::kIdentifier, "a"}, {TKT::kEq, "="},
    {TKT::kIntegerLiteral, "1"}, {TKT::kSemi, ";"},
    {TKT::kLet, "let"}, {TKT::kIdentifier, "b"}, {TKT::kEq, "="},
    {TKT::kIntegerLiteral, "2"}, {TKT::kSemi, ";"}
  }));

// "1.2.foo()" is valid, so I decide not to check what's after the second dot in lexer.
TEST_LEXER_SUCCESS(ConfusingNumberLiteral,
  "let s = 1.2.3;",
  ({
    {TKT::kLet, "let"}, {TKT::kIdentifier, "s"}, {TKT::kEq, "="},
    {TKT::kFloatLiteral, "1.2"}, {TKT::kDot, "."}, {TKT::kIntegerLiteral, "3"},
    {TKT::kSemi, ";"}
  }));

TEST_LEXER_SUCCESS(
  NumberWithDot,
  "let num = 123.foo;",
  ({
    {TKT::kLet, "let"},
    {TKT::kIdentifier, "num"},
    {TKT::kEq, "="},
    {TKT::kIntegerLiteral, "123"},
    {TKT::kDot, "."},
    {TKT::kIdentifier, "foo"},
    {TKT::kSemi, ";"}
  }));

// --- Error Cases ---
TEST_LEXER_FAILURE(UnterminatedString,
  "let s = \"hello;");

TEST_LEXER_FAILURE(UnclosedMultiLineComment,
  "let x = 1; /* unclosed comment");